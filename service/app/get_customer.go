package app

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/getbread/shopify_plugin_backend/service/bread"
	"github.com/getbread/shopify_plugin_backend/service/shopify"
	"github.com/getbread/shopify_plugin_backend/service/types"
)

func getShopifyCustomer(billingContact *bread.Contact, shippingContact *bread.Contact, shop types.Shop) (*shopify.Customer, error) {
	// copy tx.Contact to Shopify Customer
	ba := convertContactToShopifyAddress(billingContact)
	sa := convertContactToShopifyAddress(shippingContact)
	sc := convertContactToShopifyCustomer(billingContact, sa, ba)

	// search customer on Shopify
	var customer shopify.Customer
	err := searchShopifyCustomerByEmail(sc.Email, shop, &customer)
	if err == nil {
		return &customer, nil
	}

	// create customer on Shopify
	if shop.CreateCustomers {
		return postShopifyCustomer(sc, shop)
	} else {
		return &customer, nil
	}
}

func searchShopifyCustomerByEmail(email string, shop types.Shop, customer *shopify.Customer) (err error) {
	// query
	params := map[string]string{
		"email": email,
	}

	// shopify client
	sc := shopify.NewClient(shop.Shop, shop.AccessToken)
	var res shopify.SearchCustomerResponse
	if err = sc.QueryCustomer(params, &res); err != nil {
		return
	}
	if len(res.Customers) == 0 {
		err = fmt.Errorf("customer not found")
		return
	}
	*customer = res.Customers[0]
	return
}

func postShopifyCustomer(sc *shopify.Customer, shop types.Shop) (*shopify.Customer, error) {
	// shopify client
	sclient := shopify.NewClient(shop.Shop, shop.AccessToken)

	// setup request
	req := &shopify.CreateCustomerRequest{
		Customer:        *sc,
		SendEmailInvite: true,
		MetaFields: map[string]string{
			"created_by_bread": "true",
		},
	}

	// make request
	var res shopify.CreateCustomerResponse
	if err := sclient.CreateCustomer(req, &res); err != nil {
		return nil, err
	}
	return &res.Customer, nil
}

func splitContactFullName(contact *bread.Contact) (firstName, lastName string) {
	names := strings.Split(contact.FullName, " ")
	var filter = func(inputs []string) []string { // filter out names that aren't only alphanumeric
		var filtered []string
		for x := 0; x < len(inputs); x++ {
			ok, _ := regexp.MatchString("[A-Za-z0-9]", inputs[x])
			if ok {
				filtered = append(filtered, inputs[x])
			}
		}
		return filtered
	}
	namesFiltered := filter(names)
	firstName = namesFiltered[0]
	if len(names) >= 2 {
		lastName = namesFiltered[1]
	}
	return
}

func convertContactToShopifyAddress(contact *bread.Contact) *shopify.Address {
	firstName, lastName := splitContactFullName(contact)
	return &shopify.Address{
		Address1:    contact.Address,
		Address2:    contact.Address2,
		City:        contact.City,
		Country:     "United States",
		FirstName:   firstName,
		LastName:    lastName,
		Phone:       contact.Phone,
		Zip:         contact.Zip,
		Name:        contact.FullName,
		Province:    contact.State,
		CountryCode: "US",
		CountryName: "United States",
	}
}

func convertContactToShopifyCustomer(contact *bread.Contact, shippingAddress, billingAddress *shopify.Address) *shopify.Customer {
	firstName, lastName := splitContactFullName(contact)
	billingAddress.Default = true
	return &shopify.Customer{
		AcceptsMarketing: true,
		Email:            contact.Email,
		FirstName:        firstName,
		LastName:         lastName,
		Note:             "Auto-generated by Bread",
		State:            contact.State,
		Addresses:        []shopify.Address{*billingAddress, *shippingAddress},
	}
}
